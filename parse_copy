#!/Users/aaronmcleod/.rvm/rubies/ruby-1.9.2-p136/bin/ruby
$:.unshift(File.dirname(__FILE__))
require "copy_process"
include CopyProcess

file_contents_retrieved = false

# initalizes file array
files = []

puts "Please enter in the file path to the text document you wish to parse.\nSeparate multiple file names by using a semicolon."
contents = gets.chomp

# initialize variables
file_contents = ""
headers = ""

# if they entered a value, continue on
unless contents.nil? || contents == ''
  file_names = ''
  if contents.match(/^\*\.[a-z]{1,}/).nil?
    file_names = contents.split(';')
  else
    file_names = Dir[contents]
  end
  
  file_names.each do |file_name|
    # set the string to empty, so it doesn't concatenate with previous data
    file_contents = ""
    begin
      File.open(file_name.strip, 'r+') do |file| 
        file.each_line do |line|
          line = line.gsub(/\t|\n/, '').strip
          file_contents = "#{file_contents}#{line}\n" unless line == ''
        end
      end
      headers = contains_valid_headers(file_contents)
      unless headers
        raise "Headers not found in file: #{file_name}"
      else
        files << CopyFile.new(file_contents, headers[0], headers[1], headers[2], file_name)
      end
    rescue Errno::ENOENT
      puts "  Error => File not found: #{file_name}"
    end 
  end
else
  puts 'contents were nil'
end

if files.size > 0
  final_rows = []
  hash = {}
  files.each do |file_obj|
    file_obj.elements_out.each do |ele|
      final_rows << ele[0]
      if hash[ele[1]].nil?
        hash[ele[1]] = 1
      else
       hash[ele[1]] += 1
      end
    end
  end
  largest = hash.sort_by { |k,v| v }[hash.size-1][1]
  hash.each do |k,v|
    if v < largest
      final_rows << "#{k},<!-- empty -->,empty element for restrictions"
    end
  end
  
  File.open('out.csv', 'w+') do |f|
    f.write "ParentType,TypeID,ElementID,ParentTypeName,TypeName,Content,Notes\n"
    final_rows.each { |e| f.write ",,,,#{e}\n" }
  end
else
  puts 'no file objects'
end